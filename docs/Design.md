## Controllers, Actions and Commands

An analysis of the current MVC design pattern in Rails, in particular how the Controllers
are designed and can be improved by employing different Design Patterns to ensure better
decoupling, single responsibility and how to aovid the typical Rails anti-pattern of flat classes, bloated with methods.

## Using Imperator Commands in the current Controller pattern

Demonstrates just how ugly the current Controller convention is!!!

```ruby
class PostController < ApplicationController
  def update    
    update_command.valid? ? update_valid : update_invalid
  end

  protected

  def update_valid
    update_command.perform and redirect_to(root_url)
  end

  def update_invalid
    render edit_post_path(command.object)
  end

  def update_command
    @update_command ||= UpdatePostCommand.new(params[:post])
  end
end
```

## Using Imperator Commands with Focused Controllers

Much nicer encapsulated logic using FocusedController :)

```ruby
module PostController
  class Update < UpdateCommandAction
    invalid_path do
      root_url
    end

    # generated by naming convention
    # command { @command ||= UpdatePostCommand.new post_hash }
  end
end
```

Demonstrating some customization of Controller logic

```ruby
module PostController
  class Update < UpdateCommandAction
    valid do
      command.perform
      redirect_to root_url
    end

    def invalid
      flash_msg "#{command.object} was invalid!", :error
      super
    end

    command { @command ||= command_class.new object_hash.merge(:status => :complete) }
  end
end
```

And more...

```ruby
module PostController
  class Update < UpdateCommandAction
    valid do
      flash_msg "#{command.object} was valid!"
      command.perform
      puts "#{command} was performed!"
      valid_redirect
    end

    valid_redirect_path do
      root_url
    end

    def invalid
      flash_msg "#{command.object} was invalid!", :error
      super
    end

    command do
      @command ||= begin
        c = UpdatePostCommand.new post_hash
        c.complete_it!
      end
    end
  end
end
```

## Restfull Commands

If you inherit from the `Imperator::Command::Restfull` class, you gain access to the
REST convenience methods: `update`, `delete` and `create_new` which creates action methods with some default appropriate REST logic for the particular action.
See the code for more info on how to use this for your own needs.

```ruby
class UpdatePostCommand < Imperator::Command::Restfull
  attribute :some_object_id
  attribute :some_value

  validates_presence_of :some_object_id

  update do
    puts "updated OK"
  end
end
```

## Mongoid integration

Imperator also comes with a little Mongodi adaptor class, which provides the `attributes_for` method in order to easily redefine Mongoid model fields as Command attributes. Similar adaptors could be created for other ORMs such as Active Record etc.

```ruby
class UpdatePostCommand < Imperator::Mongoid::RestCommand

  attributes_for Post, except: [:status, :rating]

  validates :name, presence: true

  update do    
    puts "#{object} was updated"
  end

  on_error do
    puts "The Post could not be updated: #{object}"
  end
end
```

## Class Factory

The `Imperator::Command::ClassFactory` can be used to easily create Command wrappers for your model classes.

```ruby
Imperator::Command::ClassFactory.create :publish, Post do
  action do
    find_object.publish!
  end
end
```

It is especially handy for creating Rest Command wrappers.

```ruby
Imperator::Command::ClassFactory.use do |factory|
  factory.default_rest_class = Imperator::Mongoid::RestCommand
  factory.create_rest :all, Post do
    on_error do
      puts "Oops! There was an error!"
    end
  end

  factory.create_rest :update, Article do
    attributes_for Article, only: [:title, :body] 

    on_error do
      puts "Oops! There was an error!"
    end
  end

  # Same using :auto_attributes option
  factory.create_rest :update, Article, auto_attributes: true, except: [:status] do
    on_error do
      puts "Oops! There was an error!"
    end
  end
end
```

## Using ClassFactory macros

There are also two global macros `create_command` and `create_rest_command` available.

```ruby
# ensure all attributes of model are reflected in Command (if adaptor makes it possible)
Imperator::Command::ClassFactory.default_options = {auto_attributes: true}

module PostController
  class Update < UpdateCommandAction

    command do
      @command ||= create_rest_command(:update, Post).new object_hash
    end
  end
end
```